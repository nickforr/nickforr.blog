---
title: Loopy annuities
author: nickforr
date: '2017-07-06'
slug: loopy-annuities
categories:
  - R
tags:
  - Monte Carlo
  - Loops
  - economic scenario generator
description: ''
draft: true
topics:
  - R
---

I was tidying up some R code that involved some 'looping' and wondered whether the approach I'd taken could be improved uppon (I'd had nagging doubts over the approach but it worked and seemed fast enough, so hadn't bothered refactoring it until now).

Background is that at work we use a lot of monte carlo simulations through economic scenario generators [https://www.actuaries.org.uk/learn-develop/attend-event/economic-scenario-generators] and so are dealing with matrices with dimensions representing timesteps (for projecting, for example, interest rates) and simulations.

In this specific case, I was looking to calculate projections of annuity prices, across a large number of simulated paths for interest rates.




often the models built around the output from these don't lend themselves neatly to apply / map methods (they're typically more suited to accumulate or reduce methods).

In this case, I wanted to calculate the 

through  to keep track of some benchmarking of a couple of alternative looping approaches I was exploring 

Inspired by the request from (@hrbrmstr)[https://rud.is/b/] for short posts on useful topics, I thought 


Reference http://r.789695.n4.nabble.com/Raising-a-vector-to-the-power-of-elements-of-another-vector-td4690440.html
(googling led me to the archive for the mailing list r-help@r-project.org)





```{r}
library(tidyverse)

yieldData <- matrix(rnorm(250000, 0.03, 0.1), nrow = 50)
yieldData[1, ] <- 0

paymentProbs <- rep(0.03, 60)


y <- yieldData[3, ]
z <- drop(outer(1 + y, -seq_along(paymentProbs), "^") %*% paymentProbs)

zz <- purrr::map_dbl(y, ~ paymentProbs %*% ((1 + .x) ^ -seq_along(paymentProbs)))
all.equal(z, zz)

microbenchmark::microbenchmark({
  x_incomplete <-
    t(apply(yieldData, 1, function(y) {
      drop(outer(1 + y, -seq_along(paymentProbs), "^") %*% paymentProbs)
    }))
}, times = 20, unit = "ms")

microbenchmark::microbenchmark({
  x <- yieldData * 0
  for (i in 1:nrow(x)) {
    probs <-
      if (i == 1) {
        paymentProbs
      } else {
        tail(paymentProbs, -i + 1) / paymentProbs[i - 1]
      }
    x[i, ] <-
      drop(
        outer(1 + yieldData[i, ], -seq_along(probs), "^") %*% probs
      )
  }
}, times = 20, unit = "ms")

microbenchmark::microbenchmark({
  xx <-
    purrr::map(
      1:nrow(yieldData),
      function(i) {
        probs <-
          if (i == 1) {
            paymentProbs
          } else {
            tail(paymentProbs, -i + 1) / paymentProbs[i - 1]
          }
        purrr::map_dbl(
          yieldData[i, ],
          ~ probs %*% ((1 + .x) ^ -seq_along(probs))
        )
      }
    ) %>%
    purrr::flatten_dbl() %>%
    matrix(ncol = ncol(yieldData), byrow = TRUE)
}, times = 20, unit = "ms")

all.equal(x, xx)

```


